---
title: URL Shortening service
tags: [System Design]
style:
color: green
description: This service will provide short aliases redirecting to long URLs.
---
Tiny와 같은 URL 단축 서비스를 설계하기. 이 서비스는 긴 URL로 리다이렉션되는 짧은 aliaces를 제공한다.

### URL Shortening이 필요한 이유.

URL Shortening은 긴 URL에 대한 짧은 aliaces를 만드는데 사용된다. 우리는 이 단축된 aliases를 "short link"라고 부른다. 사용자는 이러한 Short link를 누르면 원래의 URL로 리다리렉션이 된다. Short link는 보여줄때, 출력할때 메시지를 보낼때 혹은 트위터를 할때 많은 공간을 절약해준다. 게다가 사용자들은 짧은 URL을 잘못 입력하는 경우가 있다.<br>

예를들어, 우리는 아래의 페이지를 TinyURL을 통해 줄일경우 :<br>

> https://minsuking.github.io/blog/Key-Characteristics-of-Distributed-Systems<br>

우리는 이런 결과를 얻을것이다.<br>

> http://tiny.cc/scdijz<br>

위를 보게되면 Shortened URL의 경우 실제 URL의 크기에 1/3 정도다.<br>

URL Shortening은 기기간의 링크를 최적화시키고, Audience와 Campaign performance를 분석하기위한 개별 링크를 추적하고, 연결되어있는 원래의 URL을 숨기기위해 사용된다.<br>

### 시스템의 요구사항 및 목표

> * 면접 시작할 때 요구사항을 명확하게 해야한다. 면접관이 염두에 두고있는 시스템의 정확한 범위를 찾기위해 반드시 질문을한다.<br>

URL Shortening system은 다음 요구 사항을 충족 시켜야 한다.<br>

**기능 요구 사항**<br>

1. URL이 주어지면, 이 서비스는 그것을 짦고 Unique한 alias를 만들어야한다.  이것을 위에서 이야기했던 Short link라고 한다. 이 링크는 쉽게 복사하고 붙여넣을 수 있을 정도로 짧아야 한다.<br>

2. User들이 Short link에 접근 할때, 이 서비스는 원래의 링크로 리다이렉트를 해줘야 한다.<br>

3. User는 선택적으로 자신의 url에 대한 사용자 정의 Short link를 선택 할 수 있어야한다.<br>

4. 링크는 표준 기본 시간대가 지나면 만료된다. User는 만료 시간을 지정 할 수 있어야 한다.<br>

**비 기능 요구 사항**<br>
1. 시스템의 가용성이 높아야 한다. 이 시스템이 중단된다면 모든 url 서비스의 url 리다이렉션이 실패하기 때문이다.<br>

2. url 리디렉션은 최소의 지연시간으로 실시간으로 이뤄져야한다.<br>

3. Shortened link는 추측될 수 없어야 한다.<br>

**확장 요구 사항**<br>

1. 분석이 가능해야한다. 예를 들어 리디렉션 횟수<br>

2. 이 서비스는 REST API를 통해 접근 가능해야 한다.<br>

### 시스템 API
> 일단 요구사항을 확정하고 나서 API를 정의하는 것은 항상 옳은 생각이다. 이는 시스템에서 예상되는 사항을 정확하게 명시해야한다.<br>

우리는 SOAP 또는 REST API를 통해 서비스의 기능을 노출시킬 수 있다. 다음은 URL 생성 및 삭제를 위한 API 정의이다.<br>

~~~Java
createURL(apiDevKey, originalUrl, customAlias=None, userName = None, expireDate=None)
~~~
**Parameters:**<br>
apiDevKey(String) : 등록된 계정의 개발자 API키, 이것은 할당된 할당량에 기초하여 User를 Control 하는것에 사용될 것.<br>
originalUrl : 원본 url<br>
customAlias=None : url에 대한 사용자의 지정키<br>
userName = None : 인코딩에 사용될 선택적 사용자 이름<br>
expireDate=None : 단축된 url의 만료 날짜<br>

**Returns: String)**<br>
성공적으로 Insert를 했다면 단축 URL을 리턴한다. 그렇지 않으면 error code를 반환한다. <br>

~~~Java
deleteURL(apiDevKey, urlKey)
~~~
여기서 urlKey는 검색할 단축 url을 나타내는 문자열이다. 삭제에 성공하면 url 제거에 대한 성공메시지가 반환된다.<br><br>
**우리는 어떻게 abuse를 막고 예방할 수 있을까?** 악의적인 user는 현재설계되어 있는 모든 url키를 소비함으로써 이 서비스를 망하게 할 수 있다. 남용 방지를 위해 apiDevKey를 통해 사용자를 제한 할 수 있다. 각 apiDevKey는 일정기간당 특정 url생성 및 리디렉션 수로 제한 될 수 있다.<br>

### 데이터베이스 디자인
> 인터뷰 초기단계에서 DB 스키마를 정의하는것은 다양한 요소들 간의 데이터 흐름을 이해하는 데 도움이 될 것이다.<br>

저장할 데이터의 특성에 대한 몇 가지 관측<br>
1. 우리는 수십억 개의 기록들을 보관해야 한다.
2. 각각의 Object는 용량이 작다.(1K 미만)
3. 어떤 사용자가 url을 만들었는지 저장하는것을 제외한 레코드 사이에는 아무런 relationships가 없다.
4. 이 서비스는 읽을때 무겁다.(read-heavy)

**데이터 베이스 스키마:**<br>
우리는 두 개의 테이블이 필요할 것이다. 하나는 URL 매핑에 관한 정보를 저장하기 위한 테이블이고, 다른 하나는 짧은 링크를 만든 사용자의 데이터를 저장하기 위한 테이블이다.<br>
![Schema](https://user-images.githubusercontent.com/60283244/73647590-2a43b680-46bf-11ea-941d-f9c4c3eea437.JPG)

**어떤 종류의 데이터베이스를 사용해야할까?** 우리는 수십억 개의 row를 저장할 것으로 예상되며, Object간의 relationshipis를 사용할 필요가 없기 때문에 DynamoDB, Cassandra 또는 Riak같은 NoSQL 저장소가 좋은 선택이다. NoSQL의 경우 확장하기가 더 편하다.<br>

### 기본적인 시스템 디자인 그리고 알고리즘
우리가 여기서 해결하고자 하는 문제는 받은 url에 대한 짧고 고유한 키를 생성하는 것이다.<br><br>
TinyURL을 예제를 보자면 단축 URL은 http://tiny.cc/scdijz 이다.그리고 이 URL의 마지막 6자리의 문자는 우리가 생성하고자하는 짧은 키다.<br>

*a. 실제 URL 인코딩 #*<br>
주어진 URL의 고유한 해시(예: MD5 또는 SHA256 등)를 계산할 수 있다. 그런 다음 표시를 위해 해시를 인코딩할 수 있다. 이 인코딩은 base36([a-z ,0-9]) 또는 base62([A-Z, a-z, 0-9])일 수 있으며, '+'와 '/'를 추가하면 Base64 인코딩을 사용할 수 있다. 합리적인 질문은, 짧은 키의 길이가 얼마야 되어야 하는가? 6, 8, 10자?<br>

base64 인코딩을 사용하면 6자 길이의 키를 사용할 경우 64^6 = 687억 개의 문자열이 발생할 수 있다.<br>
base64 인코딩을 사용하면 8자 길이의 키를 사용하면 64^8 = 281조 개의 문자열이 발생할 수 있다.<br>

68.7B의 고유한 문자열을 사용하면 6개의 문자 키가 우리 시스템에 충분하다고 가정해 봅시다.<br>

우리가 MD5 알고리즘을 해시함수로 사용하면 128비트 해시 값이 나올 겁니다. base64 인코딩 후에는 21자를 초과하는 문자열을 얻을 수 있다(각 base64 문자는 해시 값의 6비트를 인코딩하므로). 이제 우리는 짧은 키당 8자밖에 쓸 수 없는 공간이 있는데, 그렇다면 우리는 어떻게 우리의 키를 선택할 것인가? 열쇠는 처음 6자(또는 8자)를 가져갈 수 있다. 이 경우 키 중복이 발생할 수 있으며, 이를 해결하기 위해 인코딩 문자열에서 다른 문자를 선택하거나 문자를 교환할 수 있다.<br>

**우리의 솔루션 문제와 다른점은 무엇인가?** 인코딩 방식에는 다음과 같은 문제가 있다.<br><br>

1. 여러 사용자가 동일한 URL을 입력하면 동일한 단축 URL을 얻을 수 있는데, 이는 허용되지 않는다.
2. URL의 일부가 URL 인코딩된 경우(예: http://www.educative.io/distributed.php?id=design) 그리고 http://www.educative.io/distributed.php%3Fid%3D 설계는 URL 인코딩을 제외하고 동일하다.<br>
**문제 해결 방법:** 입력 URL마다 시퀀스 번호가 증가하여 고유하게 만든 다음 해시를 생성할 수 있다. 하지만 우리는 이 시퀀스 번호를 데이터베이스에 저장할 필요가 없다. 이 접근방식에서 발생할 수 있는 문제는 계속 증가하는 시퀀스 번호일 수 있다. 넘칠 수 있을까? 시퀀스 번호의 증가는 또한 서비스의 성능에 영향을 미칠 것이다.<br><br>

또 다른 해결책은 입력 URL에 사용자 ID(Unique해야 함)를 추가하는 것이다. 그러나 사용자가 로그인하지 않은 경우 고유 키를 선택하도록 사용자에게 요청해야 할 것이다. 이후에도 이슈가 생기면 Unique 열쇠를 얻을 때까지 키를 계속 만들어 내야 한다.<br><br>

![shorturl](https://user-images.githubusercontent.com/60283244/74006058-e9e58080-49bd-11ea-8ea1-e2b363737b5c.JPG)

*b. 키를 오프라인으로 생성 #*<br>
사전에 임의의 6개의 문자열을 생성하여 데이터베이스에 저장하는 독립형 KGS(Key Generation Service)를 가질 수 있다. (Key-DB라고 부르기) URL을 단축하고 싶을 떄마다, 우리는 이미 생성된 키 중 하나를 가지고 사용하는것이다. 이 방법은 사물을 상당히 단순히, 그리고 빠르게 만드는 것이다. 우리는 URL을 인코딩하지 않을 뿐만 아니라 중복이나 충돌에 대한 걱정할 이유가 없다. KGS는 key-db에 삽입된 모든 키가 고유한지 확인하여야한다.<br><br>

**concurrency가 문제를 일으키는가?** 키를 사용하는 즉시, 재사용 할수 없도록 데이터베이스에 표시를 해야한다. 키를 동시에 읽는 서버가 여러대 있는 경우, 우리는 두대 이상의 서버가 데이터베이스에서 동일한 키를 읽으려고 시도하는 시나리오를 얻을 수 있다. 이럴경우 이런 concurrency 문제를 어떻게 해결할 수 있을까? <br><br>

서버는 KGS를 이용하여 데이터베이스에서 키를 읽거나 표시를 할 수 있다. KGS는 아직 사용하지 않은 키(Not used yet)와 사용된 키(Used) 두개의 테이블을 사용하여 키를 저장한다. KGS는 서버 중 하나에 키를 주는 즉시, Used 테이블로 키를 옮길 수 있다. KGS는 서버가 필요로 할 때마다 신속하게 제공할 수 있다록 항상 일부키를 메모리에 보관할 수 있다.<br><br>

단순성을 위해 KGS는 메모리에 일부 키를 로드하는 즉시 Used 테이블에 키를 옮길 수 있다. 이렇게 하면 각 서버가 고유한 키를 갖게 된다. 어떤 서버에 모든 로드된 키를 할당하기 전에 KGS가 죽는다면, 우리는 그 키를 낭비하게 될 것이다. 이것은 우리가 가지고 있는 엄청난 수의 키를 고려할 때 받아들일 수 있는 수준이다.<br><br>

KGS도 여러 서버에 같은 키를 주지 않도록 해야 한다. 이를 위해 키를 제거하고 서버에 제공하기 전에 키를 잡고 있는 데이터 구조를 synchronize(or get a lock on)해야한다. <br><br>

**Key-DB 크기는?** Base64 인코딩으로 68.7억개의 고유한 키를 생성 할 수 있다.하나의 alpha numeric문자를 저장하기 위해 하나의 바이트가 필요한 경우, 밑의 용량만큼 저장 가능하다.<br>
> 6(키당 문자수) * 68.7억개(특수 키) = 412GB

**KGS는 하나의 실패점인가?** 그렇다. 이것을 해결 하기위해 우리는 KGS의 대기 복제품(standby replica)을 가질 수 있다. 주 서버가 사망할때 마 대기서버가 키를 생성하고 제공할 수 있다.<br><br>

**각 앱 서버가 key-DB에서 일부키를 캐시할 수 있을까?** 가능하다. 캐시는 확실히 속도를 낼수있기 때문이다. 이럴 경우, 모든 키를 소비하기 전에 어플리케이션 서버가 종료된다면, 우리는 결국 그 키를 잃게 될 것이다. 68억개의 고유 6자키를 가지고 있기때문에 이것을 appcetable 할 수 있다.<br><bR>

**키 조회를 어떻게 할 것인가?** 데이터베이스에서 키를 검색하여 전체 URL을 가져올 수 있다. DB에 있는 경우 Request의 "Location"필드에 저장된 URL을 전달해 "HTTP 302 Rediect" 상태를 브라우저로 다시 전송한다. 시스템에 해당키가 없다면 "HTTP 404 Not Found"상태를 발생시키거나 사용자를 다시 홈페이지로 리디렉션을 시킨다.<br><br>

**우리는 costom aliase들에 대해 크기 제한을 가해야 하는가?** 우리 서비스는 custom aliases을 지원한다. 사용자는 원하는 '키'를 선택할 수 있지만, 사용자 지정 alias를 제공하는 것은 의무적인 상황은 아니다. 그러나 우리가 잉ㄹ관된 URL 데이터베이스를 갖도록 하기위해 사용자 지정 alias 에 대한 크기 제한을 두는 것이 합리적이고 바람직할 때가 많다. 사용자가(위의 데이터베이스 스키마가 반영된) 고객 키당 최대 16자를 지정할 수 있다고 가정해보자.)<br><br>
